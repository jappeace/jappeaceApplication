#+TITLE: Excel in haskell
#+SUBTITLE: Extend excel, embrace excel, exterminate excel.

* FP Kampen
+ Corona is over~
+ For fun
+ Support
+ Job

* Motivation
I think this is quite cool tech

- Shows practical haskell power
- Excel is ubiquitous
- Bragging.

* Why use Excel

- In our case no choice.
- xlsx package 

* Why use Haskell?

* My answer
- TYPES
- Productivity
- Vibrant community
- Battle hardened

* Context
- supercede 
- reinsurance
- tradition

* Uploader
- Upload excel file
- Send to s3
- process to db
- show graphs :)

* Bordereau

| Name | Address           |      Since |
|------+-------------------+------------|
| henk | kieviet straat 8  | 2010-12-08 |
| bart | thorbecke plein 4 | 2012-12-09 |
| piet | flevoweg 12       | 2011-10-18 |

* (Initial) Processing
- Convert excell file to CSV
- Python program
- Put CSV in data types


* (Initial) Cassava

#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* Why bad?
#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* A: Why bad?
- Slow
- Lose type information 
- Type class errors lose locality

* Excell has types!
let's play is it types or text.

- 5 seconds to answer.

* Number are they types or text?
according to excel

* Types!

* Are dates types or text?
according to excel

* Text!

* Formulas are they types or text?
* Types!

* Richtext are they types or text?
* Types!

* Anyway
+ More robust validation
+ Faster validation
+ Keep locality info

* Read in memory
First attempt

#+BEGIN_SRC haskell
readExcellFile :: IO Xlsx
readExcellFile = Xlsx.toXlsx <$>
  BS.readFile "somedownloadedfile.xlsx"
#+END_SRC
* What's an xlsx

[[https://hackage.haskell.org/package/xlsx-1.1.0.1/docs/Codec-Xlsx-Types.html]]

* Lens into cells

#+BEGIN_SRC haskell
selectSheet :: Traverse' Xlsx Worksheet
selectSheet = xlSheets . ix 0 . _2

data Xlsx = Xlsx {
    _xlSheets :: [(Text, Worksheet)]
    ... }
#+END_SRC

* value lens
#+BEGIN_SRC haskell
cellValLens :: RowIndex -> ColumnIndex -> Traverse' Xlsx CellValue
cellValLens rowIx colIx =
  selectSheet . wsCells  . ix (rowIx,colIx) . cellValue . _Just

  data WorkSheet = WorkSheet {
    _wsCells :: CellMap
    ... }

  type CellMap = Map (RowIndex, ColumnIndex) Cell 
#+END_SRC
* Parsing
tag all errors
#+BEGIN_SRC haskell
data ParseErrors = NameNotFound
                 | AddressNotFound
                 | TimeNotFound
                 | TimeParseError
#+END_SRC



* Parsing
#+BEGIN_SRC haskell
parseRow :: Xlsx -> RowIndex -> Either ParseErrors BordereauRow 
parseRow xlsx rowIx = 
     name <- tagError NameNotFound $
                preview (selectSheet . cellValLens rowIx 1) xlsx
     address <- tagError AddressNotFound $
                preview (selectSheet . cellValLens rowIx 2) xlsx
     sinceRead <- tagError TimeNotFound$
                preview (selectSheet . cellValLens rowIx 3) xlsx
     since <- tagError TimeParseError $ parseTime sinceRead
     pure $ BordereauRow {..}
     where
        tagError err = maybe err pure
#+END_SRC

* Program
#+BEGIN_SRC haskell
main :: IO ()
main = do
     xlsx <- readExcellFile 
     case parseRow xlsx 1 of
       Left errr -> throwIO err
       Right res -> runDB $ insert res
#+END_SRC

* What's wrong with that?

* A
+ Memory usage 
+ An error puts in a partial result

* Streaming

#+BEGIN_SRC haskell
main :: IO ()
main = runXlsxM "somedownloadedfile.xlsx" $ do
  readSheet (makeIndex 0) $ \sheetItem -> 
    eResult <- parseSheetItem sheetItem
    case eResult of
      Left err -> throwIO err
      Right res -> runDB $ insert res
#+END_SRC

* Streaming Parser

#+BEGIN_SRC haskell
parseSheetItem :: SheetItem -> Either ParseErrors BordereauRow 
parseSheetItem  xlsx rowIx = 
     name <- tagError NameNotFound $
                preview (selectSheet . cellValLens rowIx 1) xlsx
     address <- tagError AddressNotFound $
                preview (selectSheet . cellValLens rowIx 2) xlsx
     sinceRead <- tagError TimeNotFound$
                preview (selectSheet . cellValLens rowIx 3) xlsx
     since <- tagError TimeParseError $ parseTime sinceRead
     pure $ BordereauRow {..}
     where
        tagError err = maybe err pure
#+END_SRC

* Streaming II data.validation o clock
we can accumalate errors on the rows.

* Writing files

+ Once we validated everything
+ Pretty graphs are shown
+ We need to write out our summeries and transformed data

* Streamin writing

* Correctness
+ say we add a column to our template
+ can we enforce correctness?

  YES

eg we use generics to list out our field names 
then we read the header row 
then we assert our field names == header rows.

* trippin correctness

Can I for our arbitrary database type `t`
write an excell file,
parse it with our parser,
insert it into database,
get it out again.
See if it is the same as what we started with.

We do this for all types.
Ensures parser, write code, and read code are consistent.

* Summary

+ clever use of type allows us to pinpoint errors pricesely
+ We get strong correctness gaurantees

