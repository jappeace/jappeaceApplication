#+TITLE: Excel in haskell
#+SUBTITLE: Extend excel, embrace excel, exterminate excel.

* Motivation

I think this is quite cool tech

- Shows power of haskell in a practical manner
- Excel is ubiquitous, this package and haskell will make your life easier or make you money or both.
- Programming in haskell is more productive
  and more fun then other mainstream languages
  (its not agda or Racket but definitely a step up)

* Haskell why 
- TYPES
- Productivity
- vibrant community
- battle hardened
  
* Context

* reinsurance
- Cedent (insurance company)
- tradition
- change averse

* transfer of data 
- uw needs data for fair quotation
- cedent provides otherwise no reinsurance

* Everything is excell
- Most actors are familiar with excell
  - eg broker, actuaries, underwriters etc.
- IT departments know how to create excell files
- No standardization

* Supercede business
- Provide a common excell file to rule them all
- Or provide mapping to that excell file
- Display errors
- Make graphs

* Uploader
- Upload excel file
- Send to s3
- process to db
- show graphs :)


* (Initial) Processing
- Convert excell file to CSV
- Python program
- Put CSV in data types

* Example bordereau

| Name | Address           |      Since |
|------+-------------------+------------|
| henk | kieviet straat 8  | 2010-12-08 |
| bart | thorbecke plein 4 | 2012-12-09 |
| piet | flevoweg 12       | 2011-10-18 |

* (Initial) Cassava
```haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
```

* Why does this suck?

* A: Why does this suck
- Lose type information from excell file
  - ... half our business
- Slow

* Excell has types!
let's play is it types or text.

- 5 seconds to answer.

* Number are they types or text?
according to excell

* Types!

* Are dates types or text?
according to excell

* Text!

* Formulas are they types or text?
* Types!

* Richtext are they types or text?
* Types!

* Text are they types or text?
according to excell

* Types and text!
... so there is a seperate type constructor for text.
but it' the text type.
so yes it's both.

* Anyway
+ More robust validation
+ Faster validation

* So I set out with xlsx 
and failed.

* (first attmept) Read in memory

```haskell
readExcellFile :: IO Xlsx
readExcellFile = Xlsx.toXlsx <$>
  BS.readFile "somedownloadedfile.xlsx"
```
* In theory

```haskell

selectSheet :: Lens' Xlsx Worksheet
selectSheet = xlSheets . ix 0 . _2

cellValLens :: ColumnIndex -> Lens' Worksheet
cellValLens colIx = selectSheet . ix (rowIx,colIx) . cellValue . _Just

data ParseErrors = NameNotFound
                 | AddressNotFound
                 | TimeNotFound
                 | TimeParseError

parseRow :: Xlsx -> RowIndex -> Either ParseErrors BordereauRow 
parseRow xlsx rowIx = 
   name <- tagError NameNotFound $ preview (selectSheet . cellValLens 0)
   address <- tagError AddressNotFound $ preview (selectSheet . cellValLens 1)
   sinceRead <- tagError TimeNotFound$ preview (selectSheet . cellValLens 2)
   since <- tagError TimeParseError $ parseTime sinceRead
   pure $ BordereauRow {..}
   where
      tagError err = maybe err pure

main :: IO ()
main = do
   xlsx <- readExcellFile 
   case parseRow xlsx 0 of
     Left errr -> throwIO err
     Right res -> runDB $ insert res
```

* What's wrong with that?

* A
+ Memory usage 
+ An error puts in a partial result

* Streaming

TODO example

```haskell

```

* Streaming II data.validation o clock
we can accumalate errors on the rows.

* Writing files

+ Once we validated everything
+ Pretty graphs are shown
+ We need to write out our summeries and transformed data

* Streamin writing

* Correctness
+ say we add a column to our template
+ can we enforce correctness?

  YES

eg we use generics to list out our field names 
then we read the header row 
then we assert our field names == header rows.

* trippin correctness

Can I for our arbitrary database type `t`
write an excell file,
parse it with our parser,
insert it into database,
get it out again.
See if it is the same as what we started with.

We do this for all types.
Ensures parser, write code, and read code are consistent.

* Summary

+ clever use of type allows us to pinpoint errors pricesely
+ We get strong correctness gaurantees

