#+TITLE: Excel in haskell
#+SUBTITLE: Extend excel, embrace excel, exterminate excel.

* FP Kampen
+ Corona is over~
+ For fun
+ Support
+ Job

* Motivation
I think this is quite cool tech

- Shows practical haskell power
- Excel is ubiquitous
- Bragging.

* Why use Excel

- In our case no choice.
- xlsx package 

* Why use Haskell?

* A
- TYPES
- Productivity
- vibrant community
- battle hardened

* Context
- supercede 
- reinsurance
- tradition

* Uploader
- Upload excel file
- Send to s3
- process to db
- show graphs :)

* Bordereau

| Name | Address           |      Since |
|------+-------------------+------------|
| henk | kieviet straat 8  | 2010-12-08 |
| bart | thorbecke plein 4 | 2012-12-09 |
| piet | flevoweg 12       | 2011-10-18 |

* (Initial) Processing
- Convert excell file to CSV
- Python program
- Put CSV in data types


* (Initial) Cassava

#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* Why bad?
#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* A: Why does this suck
- Slow
- Lose type information 
- Type class errors lose locality

* Excell has types!
let's play is it types or text.

- 5 seconds to answer.

* Number are they types or text?
according to excel

* Types!

* Are dates types or text?
according to excel

* Text!

* Formulas are they types or text?
* Types!

* Richtext are they types or text?
* Types!

* Text are they types or text?
according to excell

* Types and text!
... so there is a seperate type constructor for text.
but it' the text type.
so yes it's both.

* Anyway
+ More robust validation
+ Faster validation
+ Keep locality info

* Read in memory
First attempt

#+BEGIN_SRC haskell
readExcellFile :: IO Xlsx
readExcellFile = Xlsx.toXlsx <$>
  BS.readFile "somedownloadedfile.xlsx"
#+END_SRC
* What's an xlsx

[[https://hackage.haskell.org/package/xlsx-1.1.0.1/docs/Codec-Xlsx-Types.html]]

* Lens into cells

#+BEGIN_SRC haskell
selectSheet :: Lens' Xlsx Worksheet
selectSheet = xlSheets . ix 0 . _2
#+END_SRC

* value lens

#+BEGIN_SRC haskell
cellValLens :: RowIndex -> ColumnIndex -> Lens' Xlsx CellValue
cellValLens rowIx colIx = selectSheet .
    ix (rowIx,colIx) . cellValue . _Just

#+END_SRC
* Parsing
#+BEGIN_SRC haskell
data ParseErrors = NameNotFound
                 | AddressNotFound
                 | TimeNotFound
                 | TimeParseError

parseRow :: Xlsx -> RowIndex -> Either ParseErrors BordereauRow 
parseRow xlsx rowIx = 
     name <- tagError NameNotFound $
                preview (selectSheet . cellValLens rowIx 1)
     address <- tagError AddressNotFound $
                preview (selectSheet . cellValLens rowIx 2)
     sinceRead <- tagError TimeNotFound$
                preview (selectSheet . cellValLens rowIx 3)
     since <- tagError TimeParseError $ parseTime sinceRead
     pure $ BordereauRow {..}
     where
        tagError err = maybe err pure
#+END_SRC

* Program
#+BEGIN_SRC haskell
main :: IO ()
main = do
     xlsx <- readExcellFile 
     case parseRow xlsx 1 of
       Left errr -> throwIO err
       Right res -> runDB $ insert res
#+END_SRC

* What's wrong with that?

* A
+ Memory usage 
+ An error puts in a partial result

* Streaming

TODO example

#+BEGIN_SRC haskell

  example
#+END_SRC

* Streaming II data.validation o clock
we can accumalate errors on the rows.

* Writing files

+ Once we validated everything
+ Pretty graphs are shown
+ We need to write out our summeries and transformed data

* Streamin writing

* Correctness
+ say we add a column to our template
+ can we enforce correctness?

  YES

eg we use generics to list out our field names 
then we read the header row 
then we assert our field names == header rows.

* trippin correctness

Can I for our arbitrary database type `t`
write an excell file,
parse it with our parser,
insert it into database,
get it out again.
See if it is the same as what we started with.

We do this for all types.
Ensures parser, write code, and read code are consistent.

* Summary

+ clever use of type allows us to pinpoint errors pricesely
+ We get strong correctness gaurantees

