#+TITLE: Excel in haskell
#+SUBTITLE: Extend excel, embrace excel, exterminate excel.

* FP Kampen
+ Corona is over~
+ For fun
+ Support
+ Job

* Motivation
I think this is quite cool tech

- Shows practical haskell power
- Excel is ubiquitous
- Bragging.

* Why use Excel

- In our case no choice.
- xlsx package 

* Why use Haskell?

* My answer
- TYPES
- Productivity
- Vibrant community
- Battle hardened

* Context
- supercede 
- reinsurance
- tradition

* Uploader
- Upload excel file
- Send to s3
- process to db
- show graphs :)

* Bordereau

| Name | Address           |      Since |
|------+-------------------+------------|
| henk | kieviet straat 8  | 2010-12-08 |
| bart | thorbecke plein 4 | 2012-12-09 |
| piet | flevoweg 12       | 2011-10-18 |

* (Initial) Processing
- Convert excell file to CSV
- Python program
- Put CSV in data types


* (Initial) Cassava

#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* Why bad?
#+BEGIN_SRC haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
#+END_SRC

* A: Why bad?
- Slow
- Lose type information 
- Type class errors lose locality

* Excell has types!
let's play is it types or text.

- 5 seconds to answer.

* Number are they types or text?
according to excel

* Types!

* Are dates types or text?
according to excel

* Text!

* Formulas are they types or text?
* Types!

* Richtext are they types or text?
* Types!

* Anyway
+ More robust validation
+ Faster validation
+ Keep locality info

* Read in memory
First attempt

#+BEGIN_SRC haskell
readExcellFile :: IO Xlsx
readExcellFile = Xlsx.toXlsx <$>
  BS.readFile "somedownloadedfile.xlsx"
#+END_SRC
* What's an xlsx

[[https://hackage.haskell.org/package/xlsx-1.1.0.1/docs/Codec-Xlsx-Types.html]]

* Lens into cells

#+BEGIN_SRC haskell
selectSheet :: Traverse' Xlsx Worksheet
selectSheet = xlSheets . ix 0 . _2

data Xlsx = Xlsx {
    _xlSheets :: [(Text, Worksheet)]
    ... }
#+END_SRC

* value lens
#+BEGIN_SRC haskell
cellValLens :: RowIndex -> ColumnIndex -> Traverse' Xlsx CellValue
cellValLens rowIx colIx =
  selectSheet . wsCells  . ix (rowIx,colIx) . cellValue . _Just

  data WorkSheet = WorkSheet {
    _wsCells :: CellMap
    ... }

  type CellMap = Map (RowIndex, ColumnIndex) Cell 
#+END_SRC
* Parsing
tag all errors
#+BEGIN_SRC haskell
data ParseErrors = NameNotFound
                 | AddressNotFound
                 | TimeNotFound
                 | TimeParseError
#+END_SRC



* Parsing
#+BEGIN_SRC haskell
parseRow :: Xlsx -> RowIndex -> Either ParseErrors BordereauRow 
parseRow xlsx rowIx = do
     name <- tagError NameNotFound $
                preview (selectSheet . cellValLens rowIx 1) xlsx
     address <- tagError AddressNotFound $
                preview (selectSheet . cellValLens rowIx 2) xlsx
     sinceRead <- tagError TimeNotFound$
                preview (selectSheet . cellValLens rowIx 3) xlsx
     since <- tagError TimeParseError $ parseTime sinceRead
     pure $ BordereauRow {..}
     where
        tagError err = maybe err pure
#+END_SRC

* Program
#+BEGIN_SRC haskell
main :: IO ()
main = do
     xlsx <- readExcellFile 
     case parseRow xlsx 1 of
       Left errr -> throwIO err
       Right res -> runDB $ insert res
#+END_SRC

* What's wrong with that?

* A
+ Memory usage 
+ An error puts in a partial result

* Streaming

#+BEGIN_SRC haskell
main :: IO ()
main = runXlsxM "somedownloadedfile.xlsx" $ do
  readSheet (makeIndex 0) $ \sheetItem -> 
    eResult <- parseSheetItem sheetItem
    case eResult of
      Left err -> throwIO err
      Right res -> runDB $ insert res
#+END_SRC

* Streaming Parser

#+BEGIN_SRC haskell
parseSheetItem :: SheetItem -> Either ParseErrors BordereauRow 
parseSheetItem  sheetitem = do
     name <- tagError NameNotFound $
                preview (si_row . ri_cell_row . ix 1) sheetitem
     address <- tagError AddressNotFound $
                preview (si_row . ri_cell_row . ix 2) sheetitem
     sinceRead <- tagError TimeNotFound $
                preview (si_row . ri_cell_row . ix 3) sheetitem
     since <- tagError TimeParseError $ parseTime sinceRead
     pure $ BordereauRow {..}
     where
        tagError err = maybe (Left err) Right
#+END_SRC

* Streaming II data.validation o clock
we can accumalate errors on the rows.

#+BEGIN_SRC haskell
parseSheetItem :: SheetItem -> Validation [ParseErrors] BordereauRow 
parseSheetItem  sheetitem = do
     name <- tagError NameNotFound $
                preview (si_row . ri_cell_row . ix 1) sheetitem
     ...
     pure $ BordereauRow {..}
     where
        tagError err = fromEither . maybe (Left err) Right
#+END_SRC

* Writing files

+ Once we validated everything
+ Pretty graphs are shown
+ We need to write out our summeries and transformed data

* Streamin writing

#+BEGIN_SRC haskell
cellText :: Text -> Cell
cellText txt = Cell
  { _cellValue = Just CellText txt
  }

main :: IO ()
main = do
   runConduitRes $ 
    yield (MkRow 0 $ IntMap.fromList [cellText "one",  cellText "two"] )
    .| writeXlsx defaultSettings
    .| C.sinkFile "my-file.xlsx"
#+END_SRC

* Streamin writing fastly

+ alternative
  https://github.com/SupercedeTech/libxlsxwriter-hs
+ faster
+ loses expressiveness

* Correctness
+ say we add a column to our template
+ can we enforce correctness?

  YES

eg we use generics to list out our field names 
then we read the header row 
then we assert our field names == header rows.

* Okay back to the example bordereau

| Name | Address           |      Since |
|------+-------------------+------------|
| henk | kieviet straat 8  | 2010-12-08 |
| bart | thorbecke plein 4 | 2012-12-09 |
| piet | flevoweg 12       | 2011-10-18 |

* we put the header row in a vector at compile time


#+BEGIN_SRC haskell
policyBordereau :: LBS.ByteString
policyBordereau = 
  $(embedFile "bordereau-template.xlsx")

policyBordereauTemplate :: Xlsx
policyBordereauTemplate = 
  toXlsx $ LBS.fromStrict policyBordereau 
  
headerRowToVector :: Xlsx -> RowIndex -> Vector (ColumnIndex, Text)
headerRowToVector template rowNum =
  Vec.fromList $
    Supercede.Prelude.catMaybes $ takeWhile isJust $
      [columnOffset ..] <&> \x ->
        template ^? dataTraverse . cellValueAtXY (x, rowNum)
            . _Just . cellTextPrism . to (x,)

columnIndices :: Xlsx -> Vector Text
columnIndices = Vec.map snd . computerReadableHeaderRow

computerReadableHeaderRow :: Xlsx -> Vector (ColumnIndex, Text)
computerReadableHeaderRow template = headerRowToVector template
  Template.computerReadableHeaderRowNum

#+END_SRC
* getting the fieldnames

#+BEGIN_SRC haskell
module FieldNames
  ( getNames
  )
where

import GHC.Generics
import Supercede.Prelude

class FieldNames rep where
  fieldNames :: [String]

instance FieldNames f => FieldNames (M1 D x f) where
  fieldNames = fieldNames @f

instance FieldNames f => FieldNames (M1 C x f) where
  fieldNames = fieldNames @f

instance Selector s => FieldNames (M1 S s (K1 R t)) where
  fieldNames =
    [selName (error "should not be evaluated" :: M1 S s (K1 R t) ())]

instance (FieldNames a, FieldNames b) => FieldNames (a :*: b) where
  fieldNames = fieldNames @a ++ fieldNames @b

instance FieldNames U1 where
  fieldNames = []

-- | Get's the field names of a generic record
getNames :: forall a . FieldNames (Rep a) => [String]
getNames = fieldNames @(Rep a)
#+END_SRC 

* the test 

#+BEGIN_SRC haskell
spec :: Spec
spec = do
  describe "policyBordereauTemplate" $ do
    it "should have the same ordering and names as the Bordereau data type" $
      columnIndices policyBordereauTemplate `shouldBe`
       Vec.fromList (toExpectation (getNames @BordereauRow))
#+END_SRC 

* business updates
+ anyone can change the template
+ ci will tell programers what's wrong
+ asside generics, EZ!

* trippin correctness

Can I for our arbitrary database type `t`
write an excell file,
parse it with our parser,
insert it into database,
get it out again.
See if it is the same as what we started with.

We do this for all types.
Ensures parser, write code, and read code are consistent.

#+BEGIN_SRC haskell

submissionSpec :: Spec
submissionSpec = withApp $ do
  describe "roundtrip download all zip -> submission" $ it "should be able to re-submit a pack archive as a Zip-of-Xlsx submission " $ do
    -- insert a fake submission
    rows <- genFake $ runConduit $
              (do
                  fakePremiumEstimates 3 .| CC.map (\x -> x{cedentPremiumEstimateSubmissionId=pesId, cedentPremiumEstimateSubsectionId=subsectId1})
              .| sinkList

    runDB $ do
      forM_ rows $ \r -> do
        uuid <- genKey CedentPremiumEstimateKey
        P.insertKey uuid r
    withSystemTempDirectory "DownloadAllSpec_Result" $ \tmpDir -> do
        let zipFilePath = tmpDir <> "/" <> "to-re-submit.zip"
        combinedSrc <- findDataFiles pretendCacheNeverExists struct tmpDir
        runConduit $ combinedSrc .| void (zipStream $ zipOptions now' pid $ dsSubmissionMap struct) .| sinkFile zipFilePath
        rs <- runDB $ P.selectList [CedentPremiumEstimateSubmissionId P.==. pesId] sortCols

        -- running a submission with downloaded zip file
        liftIO $ void $ runServiceT ctx $ withTransaction $
          persistAndValidateAndClear pid (templatedPersited (Entity pesId2 pes2)) SExhibitPremium zipFilePath
        rs2 <- runDB $ P.selectList [CedentPremiumEstimateSubmissionId P.==. pesId2] sortCols

        before <- runDB $ P.selectList [CedentPremiumEstimateSubmissionId P.==. pesId] sortCols

        -- running a submission with downloaded zip file
        liftIO $ void $ runServiceT ctx $ withTransaction $
          persistAndValidateAndClear pid (templatedPersited (Entity pesId2 pes2)) SExhibitPremium zipFilePath
        after <- runDB $ P.selectList [CedentPremiumEstimateSubmissionId P.==. pesId2] sortCols
        let asIfSameSubmission r = r {cedentPremiumEstimateSubmissionId = pesId}
        assertEq "rows match"
          (map entityVal before)
          (sortOn sortFn rows)
        assertEq "rows match"
          (map entityVal before)
          (asIfSameSubmission . entityVal <$> after)

#+END_SRC 


* Summary

+ clever use of type allows us to pinpoint errors pricesely
+ We get strong correctness gaurantees

