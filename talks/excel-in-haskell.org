#+TITLE: Excel in haskell
#+SUBTITLE: Extend excel, embrace excel, exterminate excel.

* Motivation

I think this is quite cool tech

- Shows power of haskell in a practical manner
- Excel is ubiquitous, this package and haskell will make your life easier or make you money or both.
- Programming in haskell is more productive
  and more fun then other mainstream languages
  (its not agda or Racket but definitely a step up)

* Haskell why 
- TYPES
- Productivity
- vibrant community
- battle hardened
  
* Context

* reinsurance
- Cedent (insurance company)
- tradition
- change averse

* transfer of data 
- uw needs data for fair quotation
- cedent provides otherwise no reinsurance

* Everything is excell
- Most actors are familiar with excell
  - eg broker, actuaries, underwriters etc.
- IT departments know how to create excell files
- No standardization

* Supercede business
- Provide a common excell file to rule them all
- Or provide mapping to that excell file
- Display errors
- Make graphs

* Uploader
- Upload excel file
- Send to s3
- process to db
- show graphs :)

* (Initial) Processing
- Convert excell file to CSV
- Python program
- Put CSV in data types

* (Initial) Cassava
```haskell
data BordereauRow = MkBordereauRow 
 { name :: Text
 , address :: Text
 , since :: UTCTime
 } deriving FromCSV
```

* Why does this suck?

* A: Why does this suck
- Lose type information from excell file
  - ... half our business
- Slow

* Excell has types!
let's play is it types or text.

- 5 seconds to answer.

* Number are they types or text?
according to excell

* Types!

* Are dates types or text?
according to excell

* Text!

* Formulas are they types or text?
* Types!

* Richtext are they types or text?
* Types!

* Text are they types or text?
according to excell

* Types and text!
... so there is a seperate type constructor for text.
but it' the text type.
so yes it's both.

* Anyway
+ More robust validation
+ Faster validation

* So I set out with xlsx 
and failed.

* (first attmept) Read in memory

```haskell
readExcellFile :: IO Xlsx
readExcellFile = Xlsx.toXlsx <$>
  BS.readFile "somedownloadedfile.xlsx"
```
* In theory

```haskell

selectSheet :: Lens' Xlsx Worksheet
selectSheet = xlSheets . ix 0 . _2

cellValLens :: ColumnIndex -> Lens' Worksheet
cellValLens colIx = selectSheet . ix (rowIx,colIx) . cellValue . _Just

data ParseErrors = NameNotFound
                 | AddressNotFound
                 | TimeNotFound
                 | TimeParseError

parseRow :: Xlsx -> RowIndex -> Either ParseErrors BordereauRow 
parseRow xlsx rowIx = 
   name <- tagError NameNotFound $ preview (selectSheet . cellValLens 0)
   address <- tagError AddressNotFound $ preview (selectSheet . cellValLens 1)
   sinceRead <- tagError TimeNotFound$ preview (selectSheet . cellValLens 2)
   since <- tagError TimeParseError $ parseTime sinceRead
   pure $ BordereauRow {..}
   where
      tagError err = maybe err pure

main :: IO ()
main = do
   xlsx <- readExcellFile 
   case parseRow xlsx 0 of
     Left errr -> throwIO err
     Right res -> runDB $ insert res
```

* What's wrong with that?

* A
+ Memory usage explodes on large rowsets
+ An error puts in a partial result
+ 
